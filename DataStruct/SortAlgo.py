#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" 排序算法的原理以及Python实现
冒泡, 选择, 插入, 希尔, 归并, 快速, 堆排序, 计数排序, 桶排序, 基数排序
排序算法的说明:
    稳定: 如果a在b前面, a=b, 排序后a仍然会在b的前面
    不稳定: 如果a在b前面, a=b, 排序后a可能会在b的后面
    内排序: 所有排序操作都在内存中完成
    外排序: 由于数据太大, 因此把数据放在磁盘中, 而排序通过磁盘和内存的数据传输才能进行
    时间复杂度: 一个算法执行耗费的时间, (我们一般情况下说的都是平均时间复杂度)
    空间复杂度: 运行完一个程序所需要的内存的大小
排序算法分类:
    比较排序: 快速排序,归并排序,冒泡排序,堆排序,选择排序等属于比较排序,在排序的最终结果里,元素之间的次序依赖他们之间的比较。
        每个数都必须和其他数进行比较,才能确定自己的位置. 普遍时间复杂度为O(n^2), 通过分治法可以削减为logN次,所以时间复杂度
        为O(nlogn), 并且比较排序算法时间复杂度也不能突破O(nlogn), 因此也成为非线性时间比较排序
    非比较排序:计数排序,基数排序,桶排序属于非比较排序. 非比较排序是通过确定每个元素之前, 应该有多少个元素来排序, 针对数组arr,
        计算arr[i]之前有多少个元素, 则唯一确定了arr[i]在排序后数组中的位置.
        非比较排序只要确定了每个元素之前的已有的元素个数就可以了,所以一次遍历就可进行排序,时间复杂度为O(n)

"""


# 冒泡排序: 内部排序, 稳定,
def BubbleSort(alist: list) -> list: 
    """
    冒泡排序的原理:
        重复的走访需要排序的数列, 一次比较两个元素，如果他们的顺序错误就把他们交换过来。
        走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
        1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个
        2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
        3. 针对所有的元素重复以上的步骤，除了最后一个。
        4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
    助记码:
        i∈[0,N-1)               //循环N-1遍
            j∈[0,N-1-i)           //每遍循环要处理的无序部分
                swap(j,j+1)          //两两排序（升序/降序）
    """
    for i in range(len(alist)-1):           # 第一层循环决定需要进行多少次比较
        for j in range(len(alist)-1-i):     # 第二层循环遍历进行比较
            if alist[j] > alist[j+1]:
                alist[j], alist[j+1] = alist[j+1], alist[j]
    return alist


def TestSort() -> None:
    alist = [3, 1, 9, 24, 12, 34, 56, 97, 25]
    print('BubbleSort: ', BubbleSort(alist))


if __name__ == '__main__':
    TestSort()
